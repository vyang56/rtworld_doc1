# 一个小团队框架的实现
by StreetYang

## 问题和基本方案
> 小团队核心问题是：难以流程化
- 人少，工作杂乱
  - 无法集中注意力做好一件事
  - 无法准确认知当前任务的重要性
- 没有流程和文档
  - 没做过的东西不会做
  - 做过的东西不会调
  - 重复工作，重复踩坑
- 定目标随意
  - 频繁中断、调整、无法完成时产生消极情绪
  - 员工容易对目标怀疑，无热情
- 没有人力储备
  - 推进容易中断
  - 管理层没底气，只能哄

> 方案：让流程显得更自然
- 每个服务、项目独立
  - 可独立启动
  - 提供带测试功能的文档
- 成果物 `不分离`
  - 开发、发布代码不分离
  - 文档、工具、测试用例不分离
  - 包和源码不分离
- 对自动化优化
  - 生成友好
  - 部署友好
- 分别处理 `标准件` 和 `定制件`
  - 标准件尽可能小而稳定，理解难度低，易组装
  - 定制件由可由标准件定制而来
- 管理层先试错
  - 借助标准件，开发原型系统评估
  - 根据原型系统做原型图
- 数字化助手替代wiki（TODO）
  - 快速输入
  - 快速输出 

## 业务模型
> 借鉴 腾讯《超级链接》对业务的结构模型：人，物，场
- 人：使用者和各自的身份。泛指发起事件的主体
- 物：数据和数据关联。泛指从各唯独和来源的数据
- 场：产生数据变动的场景。

## 数据模型
> 数据模型尽可能使用关系数据库作为基础，使用左连接作为关联手段
- 理解优先，结构优先
- 可以通过冗余字段、其他数据形式满足业务的实际需求，但应以原始数据为基准

> 通过自己定义的结构和界面配置数据模型。

> 尝试过使用Power Designer、visio、PD Man或者直接写在数据库里，但因为取舍倾向不同，还是花点时间自己做了。

- 基础约定和字段配置
  - 主键叫`id`，自增数字类型，默认。如有GUID需要额外加
  - 逻辑删除标识`is_delete`。
  - 枚举：
    - *_type, *_state, 非枚举类型type前不加下划线
    - tinyint类型
    - 统一描述形式：0:val1, 1:val2, 2:val3
  - 外键
    - *_id，非外键类型id前不加下划线
    - 数字类型
    - 统一描述形式：group@model#sheetName.id:name
  - 复杂类型
    - *_atts
    - 编辑器类型：json：使用通用json编辑器。editor：自定义编辑器类型
  - 静态值
    - 和代码生成工具约定的默认值
  - 其他的约定
    - 数据类型：int, varchar, text, tinyint
    - 数据来源：number, text, select, picker, static
    - 可检索类型：equal, contain, startWith, endWidth
    - 列表类型：title, attrubute, icon,
    - 编辑器类型：default, readonly, hide, textarea, json, image, editor
- 其他数据模型描述
  - 对应的分组（数据库名）
  - 数据表名
  - 实体名
  - 默认排序
  - 默认行为：创建、修改、删除

## 实体模型
> 借鉴C# LINQ的理念，实体对应着能操作的数据，所以能增删改查的东西，理论上都能伪装成实体
- 对应关系数据库的表，或视图
- 其他类型数据库查的数据
- 缓存中的数据
- 从其他接口接来的数据
- 也不知道是从哪蹭来的数据，反正就是异步的数据

> 实体的首要作用是对编程友好，对外提供一组没有异议的接口
- 拥有一个统一的查询方式
- 可预期格式的查询结果
- 简单的更新方式
- 简单的关联查询（单条关联或批量关联）
- 简单的枚举转换（单条关联或批量转换）
- 支持扩展操作
  - 自定义查询、更新
  - 伪装的触发器（不在数据库触发器）
  - 类似MyBatis的可配置功能

> 借鉴sql的关键词和链式调用，实现了以下功能
- 实体提供的公共方法
  - 增 xxx.insert({value:1})
  - 改 xxx.update({value:1},{id:1})
  - 删 xxx.delete({id:1})
  - 查
```
xxx.select()        // .select(field?: string, where?: string | object | Array<string>, order?: string): Select;
  .filed('a,b,c')   // .field(v: string): Select;
  .where({id:1})    // .where(v: string | object | Array<string>): Select;
  .order('id')      // .order(v: string): Select;
  .group('group)    // .group(v: string): Select;
  .limit(3)         // .limit(count: number, offset?: number): Select;
  .toSql()          // .toSql(): string; 构建为sql语句
                    // .getInt(paras: any | Array<any>): Promise<number | null>;
                    // .getValue(paras: any | Array<any>): Promise<string | number | null>; 
                    // .getOne(paras: any | Array<any>): Promise<object | null>;
                    // .getList(paras: any | Array<any>): Promise<Array<object>>;
                    // .getPage(paras: Array<any>, pageSize: number, pageIndex: number): Promise<{rows:[],total:number}>;
```
  - 自定义查询 xxx.query('select ?', [1]);
  - 附加外部数据(关联表中的数据)
```
  xxx.buildOuter(rows, { category_id: 'root' });
  xxx.buildOuter(r1.rows, ['category_id']);
```
  - 事物支持


## 服务模型
> 服务需要便于部署，便于升级，且环境和依赖不应对服务产生过多影响。
- 结构 nginx + docker(compose) + amount
- nginx：负责反向代理 + 分流。如果需要前置监控，用openresty替代。
- 使用docker的通用镜像 + compose配置部署工具
- 通过amount功能将代码部分映射到服务器对应文件夹中（包括nginx的配置文件、代码包、项目配置文件）
- 对应文件夹git clone对应仓库
- 特点：
  - 不是把项目做成docker，而是用docker仅做环境。
  - 没有通过k8s编排服务，只是通过compose配置独立的服务。
  - 借助Git和jenkins发布速度快，支持源码级发布，便于持续集成。
  - 不足：扩容的首次部署时间较长。
  - 可以在宿主服务器直接修改源码
  - 没有注册中心的概念，没有保活，启动顺序需要手动控制。

## 接口模型
> 接口应具有无歧义的输入和输出，统一的成功、失败、参数、头等形式
- 标准件
  - post请求
  - https: //模块 /控制器路径（多层） /方法
  - 没有使用restAPI
    - 相同的谓词+不同的路径 并不比 不同的谓词+不同的路径难理解
    - 不同的业务难以界定谓词
    - GET不能带头，传token需要违反约定
- 请求
  - API尽可能用post，因为想在head里携带token
  - 路径：请求的路径直接映射到后端文件路径，不借助路由表
- 请求过程
  1. 记录入口日志
  2. 过滤不合法的请求
    - 路径形态过滤  `rgx = /(\/\/)|(\.\.)|(^_)|(\/_)|(\/$)/;`
  3. 初始化控制器 `new Api(ctx)`
  4. 执行方法前校验 ：token检验，放行等
  5. 执行方法
    - 验证输入
    - 执行结果
    - 记录执行日志
    - 包装返回值或错误信息
  6. 记录出口日志
- 返回值
  - 成功和错误的返回值包装方法在配置文件中，便于快速适配。
  - 当前成功、失败返回值借鉴微信开放平台接口样式。
  - 成功：{errcode:0, data:{}}
  - 失败：{errcode:-1, errmsg:'english', detail:{}}

- 长连接 websocket
  - 通过http/GET协议升级websocket协议
  - 首次握手时发送token，因为没头
  - 首次握手成功时，服务端创建实例时执行验证方法。

- 参数和校验
  - 参数以类似键值对的形式接收，避免结构化（多层、复杂类型）
    - k1=v1&k2=v2
    - {k1:v1,k2:v2}
    - ```<xml><k1>v1</k1><k2>v2</k2></xml>```
  - 对每一个参数进行基本校验，并赋值
  - 校验分三种形式
    - 验证是数字并转为数字
    - 通过正则表达式验证字符串
    - 通过数组验证枚举
    - 通过方法（委托）验证参数
  - 错误处理两种方式
    - 将错误信息加入错误队列
    - 转换为默认值
  - 返回参数错误包含 `错误信息` 和 `详细的错误信息`
  
  ``` {errcode:-1,errmsg:'input invalid', detail:['k1 invalid', 'k2 invalid']} ```

## 执行日志
> 日志主要产生于 `接口的调用` 和 `计划任务的执行`，也会产生于服务`启动`、`重启`。

> 日志存储在mysql中，执行SQL时采用异步不等待原则。可以改为mongodb或单独的服务。

> 每个服务有单独的server_id，每个请求或事件(计划任务执行、启动、重启)都有单独的id

- 入口日志
    - 分配请求编号 req_id
    - method href path get ip ua token referer i_time post
    - 问题：post属于body中的内容，是一个异步流。输入时候记，容易被饱和攻击。不记还不好分析失败的请求。
    - 解决方案：独立上传操作，限制请求大小。
- 执行日志
  - 如果请求未返回，将log/warn写入ctx
  - 如果请求已返回（即延时方法），写入缓存，待触发器批量更新到日志库
- 出口日志
  - status errcode result log warn
- 延时日志
  - 如果请求已返回，出口日志已输出结束，但控制器或服务仍在执行，产生的log和warn仍然应该记录在这个请求的日志下
  - 方法：产生的日志会携带请求编号缓存，定期由调度程序追加到出口日志中

## 业务逻辑层
> 因为业务逻辑比较简单，此前项目这层很轻。大部分是接口直接调实体
- 业务层的依然需要验证输入参数
- 返回值需要明确状态，成功或失败
- 建议捕获业务层产生的错误

## 用户界面套壳
> APP和小程序对于用户友好，但更新受应用市场的审查影响

> H5不受影响，但接入方式不友好

- 小程序接入H5，APP略有不同
  - 使用Webview控件接入
  - 无法去掉title-bar
  - 小程序必须完成企业认证，并将域名小程序纳入白名单
  - 传值只能通过url
  - 应用首页建议原生
- H5调用JS-SDK
  - H5页面以公众号身份注册配置，可以使用JS-SDK提供的功能
- H5视图调用小程序视图
  - wx中提供了H5调用小程序视图的方法
- 小程序视图调用H5视图
  - 打开新的包含webview的视图，通过url传值
- 小程序视图回调H5视图
  - 利用webview的hash事件，达成了回调功能。

## H5的适配和调试
> H5在移动设备中会产生预期之外的效果
- 调试
  - 通过5个手指头，连续触摸屏幕5次开启（因为iphone就支持5点触摸）
  - 异步加载vconsole模块，因为正常人都不用，而且包也不小
- CSS框架 group
  > 提供一组最基础的样式，用于组装原型系统。并尽可能让他在实际生产中也不那么难看
  - 1px边框支持：通过像素比设置形状变换实现1px效果，但如果用PC浏览器模拟手机，会有预期外的效果
- shadowDom的坑
  - 对于iphone，shadowDom无法触发微信按住识别二维码功能
  - shadowDom中css引用的自定义字体和rpx参照，来自宿主
  - 对富文本编辑器的支持很不好

## 用户令牌
> 用户令牌系统借鉴JWT实现逻辑，即声明-内容-验证
- 令牌具有自验证功能，可携带关键信息。可同步验证并解析数据。
- 配合返回值，可完成令牌的自动更新功能。

## 视图的组织
- 页面与接口
  - 鉴于业务变化频繁，主要接口依据用户侧逻辑进行组织
    - 优点：耦合性低，定制性高，接口可验证调用方
    - 缺点：相同功能接口重复。完全分离的前后端团队没办法理解
  - 所有接口公用同一套解析/错误处理逻辑
  - 所有接口post，携带相同结构的token
- 宿主页
  - 宿主页是应用入口，承载所有视图
  - 提供统一的错误处理方案
  - 宿主页承载应用的公共信息和公共库
- 视图
  - 源码：html+css+js 借鉴小程序
  - 发布：b.js
  - 每个视图都可以被独立调用，可以被宿主页调用，也可以被其他视图调用和嵌入
  - 视图服务可以共享宿主页数据，并包含上下文的视图引用
  - 视图服务器支持跨域调用
  - 视图支持单独刷新，支持入参，支持事件
  - 优点：独立，低耦合，运行时载入
  - 缺点：开发难度较高
- 工具视图
  - 如提示框，输入框等
  - 与宿主页绑定
  - 可以做到不同宿主页，调用同样的视图，使用各自的提示框
- 
## 错误处理
- 如果请求通过nginx，进入服务，所有的错误都以统一的格式返回
- {errcode:-1, errmsg:'english', detail:{}}
```
0 - 未进入api模块
100 - 进入了api模块
200 - 找到了对应路由规则
300 - url合法性验证通过
400 - 找到了对应的处理模块
500 - 初始化模块成功（用类成功创建了实例）
600 - 通过了前置验证（beforeFn，权限验证）
700 - 找到了处理方法
800 - 处理方法可以使用（不是非法访问私有对象）
900 - 方法处理了请求并常规返回（没有抛出异常）
-1 - 懒了没定义
1000+ 或 100- 业务处理错误
```
- 前端接口错误采用分级处理
  - 访问接口失败
    - 网络错误 1 请求都发不出去：断网。错误详情是fetch的error.message。附带url+错误对象
    - 请求错误 2 有返回值，但不是response.ok。错误详情是response.status + response.statusText。附带url+返回的字符串+response对象
    - 解析错误 3 返回值不能解析为JSON或执行自定义解析方法出错。错误信息是解析的error.message。附带url+返回的字符串+错误对象
  - 执行错误 4
    - 格式错误 41 errcode不是数字 错误信息是返回内容
    - 操作失败 42 errcode不是0 服务器返回的不成功信息

## 自动化生成
- 数据库生成
  - 生成SQL语句 -> 执行SQL语句
  - 如果存在同名表
    - 策略1：先删除再创建 -> 会清除原数据，仅适用于测试
    - 策略2：不操作，提示人工接入处理 -> 不会清除数据，也不会做什么
    - 策略3：通过分析表和字段，修改表 -> 处理难度比较大，而且不一定处理成功

- 代码文件生成
  - 需要定义，生成的代码是否可以被人工修改
  - 可以修改
    - 多次生成策略：直接覆盖 / 通过验证hash值选择覆盖
  - 不可以修改
    - 生成代码以partical（C#），Mixin（Js），基类/抽象类形式存在，自定义代码和生成代码完全分离。
  
- 代码片段生成
  - 策略1：通过自定义占位符（插入点）生成片段 -> 重复生成会出现问题，对自定义友好
  - 策略2：二次生成
    - 步骤：将片段生成位单一文件，每一次生成后，将所有片段重新组合成文件
    - 特点：重复生成不会出现问题，对自定义不友好
  
- 文档生成
  - 通过扫描接口文件的注解，生成基础版本的文档结构
  - 人工完善基础文档结构，如需重新生成接口，删除或标记对应的接口片段
  - 通过基础文档结构重新生成文档和测试用例

- 数据关联图
  - 根据外键关系生成数据关联图，便于填坑时理解

## 持续集成
- 代码提交到Git - dev分支
- 通过自动化脚本，如果需要先编译，合并到α分支，通过Jenkens脚本，通知服务器拉取最新代码，如有需要重启docker服务。
- 测试通过，合并到β分支，通过Jenkens脚本，通知服务器拉取最新代码，如有需要重启docker服务。
- 集成化测试后，合并到γ分支。运维人员手动重启docker服务。
- 配置文件更新：合并分支前更新配置文件
- 数据库更新：合并分支前，对比数据库（借助navicat）结构并更新

## 持续部署
- 持续部署需要更新nginx。如果连续服务要求较高，需要做两层nginx
